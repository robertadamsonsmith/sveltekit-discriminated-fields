import { discriminatedFields, type DiscriminatedData } from '../../src/index.js';

// =============================================================================
// Type equality helpers
// =============================================================================

type Equal<X, Y> =
	(<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;

type Expect<T extends true> = T;

// =============================================================================
// SvelteKit form field types
//
// SvelteKit's $app/server/remote is a virtual module that only works inside
// a SvelteKit project. These types replicate the structure that SvelteKit
// produces for form fields.
// =============================================================================

/** Matches SvelteKit's RemoteFormField<T> */
type Field<T> = {
	value(): T;
	as(type: 'hidden' | 'number' | 'select' | 'string'): Record<string, unknown>;
	issues(): Array<{ message: string; path?: string[] }> | undefined;
};

/** Common methods on all form field objects */
type FormMethods<TData> = {
	set(data: TData): void;
	allIssues(): Array<{ message: string; path?: string[] }> | undefined;
};

/**
 * Replicates SvelteKit's transformation from data type to fields.
 * Distributes over union to create a union of field objects.
 */
type ToFields<TData, TFullData = TData> = TData extends unknown
	? FormMethods<TFullData> & { [K in keyof TData]: Field<TData[K]> }
	: never;

// =============================================================================
// Example: Schema data type (as generated by Zod/Valibot)
// =============================================================================

type ShapeData =
	| { kind: 'circle'; radius: number }
	| { kind: 'rectangle'; width: number; height: number }
	| { kind: 'point' };

// =============================================================================
// SvelteKit transforms this into a union of field objects
// =============================================================================

type ShapeFields = ToFields<ShapeData>;

// Verify this produces the expected structure:
type ExpectedShapeFields =
	| (FormMethods<ShapeData> & { kind: Field<'circle'>; radius: Field<number> })
	| (FormMethods<ShapeData> & { kind: Field<'rectangle'>; width: Field<number>; height: Field<number> })
	| (FormMethods<ShapeData> & { kind: Field<'point'> });

type _verifyToFields = Expect<Equal<ShapeFields, ExpectedShapeFields>>;

// =============================================================================
// The Problem: variant-specific fields are inaccessible without narrowing
//
// With a union of field objects, TypeScript only allows access to properties
// that exist on ALL variants. Variant-specific fields cannot be accessed at
// all, and kind.value() doesn't enable narrowing because method calls don't
// provide control flow analysis.
// =============================================================================

declare const shapeFields: ShapeFields;

// Only the discriminator field (present on all variants) is accessible
shapeFields.kind;
shapeFields.set;
shapeFields.allIssues;

// @ts-expect-error - radius only exists on circle variant
shapeFields.radius;

// @ts-expect-error - width only exists on rectangle variant
shapeFields.width;

// @ts-expect-error - height only exists on rectangle variant
shapeFields.height;

// Checking kind.value() doesn't help - method calls don't narrow
if (shapeFields.kind.value() === 'circle') {
	// @ts-expect-error - still can't access radius, no narrowing occurred
	shapeFields.radius;
}

// =============================================================================
// The Solution: discriminatedFields() makes all fields accessible and enables
// narrowing via the kindValue property
// =============================================================================

declare const shapeFields2: ShapeFields;
const shape = discriminatedFields('kind', shapeFields2);

// DiscriminatedData extracts the original data type
type _verifyExtraction = Expect<Equal<DiscriminatedData<typeof shape>, ShapeData>>;

// Common fields accessible without narrowing
shape.kind;
shape.kindValue;
shape.set;
shape.allIssues;

// kindValue can be undefined (form not yet initialized)
if (shape.kindValue === undefined) {
	// valid - handles unset state
}

// Narrowing works for circle variant
if (shape.kindValue === 'circle') {
	shape.radius;
	shape.kind;

	// @ts-expect-error - width doesn't exist on circle variant
	shape.width;

	// @ts-expect-error - height doesn't exist on circle variant
	shape.height;
}

// Narrowing works for rectangle variant
if (shape.kindValue === 'rectangle') {
	shape.width;
	shape.height;
	shape.kind;

	// @ts-expect-error - radius doesn't exist on rectangle variant
	shape.radius;
}

// Narrowing works for point variant (no extra fields)
if (shape.kindValue === 'point') {
	shape.kind;

	// @ts-expect-error - radius doesn't exist on point variant
	shape.radius;

	// @ts-expect-error - width doesn't exist on point variant
	shape.width;
}

// set() accepts valid variants
shape.set({ kind: 'circle', radius: 5 });
shape.set({ kind: 'rectangle', width: 10, height: 20 });
shape.set({ kind: 'point' });

// set() rejects invalid data
// @ts-expect-error - missing required field
shape.set({ kind: 'circle' });

// @ts-expect-error - wrong field for variant
shape.set({ kind: 'circle', width: 10 });

// @ts-expect-error - unknown kind
shape.set({ kind: 'triangle' });

// =============================================================================
// Tests: works with 'type' as discriminator key
// =============================================================================

type PaymentData =
	| { type: 'card'; cardNumber: string; cvv: string }
	| { type: 'bank'; accountNumber: string; sortCode: string }
	| { type: 'cash' };

declare const paymentFields: ToFields<PaymentData>;
const payment = discriminatedFields('type', paymentFields);

type _verifyPayment = Expect<Equal<DiscriminatedData<typeof payment>, PaymentData>>;

// Has typeValue when discriminator is 'type'
payment.typeValue;

if (payment.typeValue === 'card') {
	payment.cardNumber;
	payment.cvv;

	// @ts-expect-error - accountNumber doesn't exist on card variant
	payment.accountNumber;
}

if (payment.typeValue === 'bank') {
	payment.accountNumber;
	payment.sortCode;

	// @ts-expect-error - cardNumber doesn't exist on bank variant
	payment.cardNumber;
}

if (payment.typeValue === 'cash') {
	// @ts-expect-error - cardNumber doesn't exist on cash variant
	payment.cardNumber;

	// @ts-expect-error - accountNumber doesn't exist on cash variant
	payment.accountNumber;
}

// =============================================================================
// Tests: fields shared across multiple variants
// =============================================================================

type NotificationData =
	| { channel: 'email'; address: string; subject: string }
	| { channel: 'sms'; address: string }
	| { channel: 'push'; deviceId: string };

declare const notificationFields: ToFields<NotificationData>;
const notification = discriminatedFields('channel', notificationFields);

type _verifyNotification = Expect<Equal<DiscriminatedData<typeof notification>, NotificationData>>;

// address exists on email and sms, but not push
if (notification.channelValue === 'email') {
	notification.address;
	notification.subject;
}

if (notification.channelValue === 'sms') {
	notification.address;

	// @ts-expect-error - subject only exists on email
	notification.subject;
}

if (notification.channelValue === 'push') {
	notification.deviceId;

	// @ts-expect-error - address doesn't exist on push
	notification.address;
}
